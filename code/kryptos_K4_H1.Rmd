---
title: "Kryptos K4 Hypothesis 1"
author: "Kenny Shirley"
date: "September 25, 2019"
output: 
  html_document:
    smart: FALSE
    toc: TRUE
    theme: readable
editor_options: 
  chunk_output_type: console
---
  
```{r global-options, include = FALSE}
## Global options
knitr::opts_chunk$set(echo = TRUE, 
                      warning = FALSE, 
                      message = FALSE, 
                      cache = FALSE, 
                      comment = "")
```

```{r set-options, echo=FALSE}
#setwd("~/public_git/kryptos/code")
options(width = 80)
library(dplyr,      quietly = TRUE)
library(knitr,      quietly = TRUE)
library(tidyr,      quietly = TRUE)
library(data.table, quietly = TRUE)
library(ggplot2,    quietly = TRUE)
library(plotly,     quietly = TRUE)
```


## K4 Hypothesis 1

Hypothesis: Keyed Vigenere

- keyword = single word in Scrabble list (n = 178,691)

- alphabet = “kryptos” (as displayed in the sculpture)

First, we'll load the required data and functions:

``` {r decode}
cipher_text <- readLines("../data/ciphertext.txt")
vigenere_table <- readLines("../data/vigenere_table.txt")
K4 <- unlist(strsplit(paste(cipher_text[25:28], collapse = ""), ""))[28:124]

# function to decrypt a cipher using a vigenere table and a key:
decode_vigenere <- function(cipher, key, vigenere_table) {
  stopifnot(all(cipher %in% c(LETTERS, "?")))
  stopifnot(all(key %in% LETTERS))
  row_indices <- match(key, V[, 1])
  qmark <- cipher == "?"  # force a "?" to decode to itself
  r <- row_indices[0:(length(cipher[!qmark]) - 1) %% length(row_indices) + 1]
  D <- matrix(match(V[r, ], LETTERS) - rep(match(cipher[!qmark], LETTERS), 26), 
              nrow = length(cipher[!qmark]), 
              ncol = 26)
  # one entry in each row of D equals zero, except for question marks, which are rows of NA
  out <- rep("", length(cipher))
  out[!qmark] <- V[1, (which(t(D) == 0) - 1) %% 26 + 1]
  out[qmark] <- "?"
  out
}

# store the value of the Kryptos Vigenere table in a matrix:
V <- vector("list", 26)
alphabet <- rep(unlist(strsplit("KRYPTOSABCDEFGHIJLMNQUVWXZ", split = "")), 2)
for (i in 1:26) V[[i]] <- alphabet[1:26 + i - 1]
V <- do.call(cbind, V)

# read in the scrabble dictionary:
scrabble <- readLines("../data/TWL06.txt")

# read in the 2-gram frequencies from the Google n-grams corpus:
two_gram <- fread("../data/count_2l.txt", data.table = FALSE)
names(two_gram) <- c("letters", "frequency")

# normalize the frequencies to avoid integer overflow:
two_gram$normalized <- two_gram$frequency / min(two_gram$frequency)

# build the transition matrix for the bigram model of English:
two_mat <- matrix(0, 26, 26)
row_index <- match(substr(two_gram$letters, 1, 1), letters)
col_index <- match(substr(two_gram$letters, 2, 2), letters)
two_mat[cbind(row_index, col_index)] <- two_gram$normalized
rownames(two_mat) <- LETTERS
colnames(two_mat) <- LETTERS

# divide by row sums to get probabilities:
theta <- two_mat / rowSums(two_mat)

# get initial state distribution:
p <- rowSums(two_mat) / sum(two_mat)

# function to compute the log-likelihood of a particular snippet of text:
markov_score <- function(sequence, trans_matrix = theta, initial_probs = p) {
  n <- length(sequence)
  row_indices <- match(sequence[1:(n - 1)], LETTERS)
  col_indices <- match(sequence[2:n], LETTERS)
  as.numeric(log(p[match(sequence[1], LETTERS)])) + 
    sum(log(theta[cbind(row_indices, col_indices)]), na.rm = TRUE)
}
```

Now, test the hypothesis:

``` {r test}
# Now, try all the words in the Scrabble dictionary for K4:
candidate <- vector("list", length(scrabble))
loglik <- numeric(length(scrabble))
for (i in 1:length(scrabble)) {
  candidate[[i]] <- decode_vigenere(cipher = K4,
                                    key = unlist(strsplit(scrabble[i], split = "")), 
                                    vigenere_table = V)
  loglik[i] <- markov_score(sequence = candidate[[i]])
}

# look at the top 10 most likely messages (and keywords):
top <- order(loglik, decreasing = TRUE)[1:10]

out <- data.frame(key = scrabble[top], 
                  loglik = loglik[top], 
                  message = sapply(candidate[top], 
                                   function(x) {paste0(paste(x[1:40], collapse = ""), "...")}))

out
```

**Conclusion: False.**

Just for a little more information, let's look at the histogram of the log-likelihood values:

``` {r loglik-hist}
hist(loglik, breaks = 15)
```






