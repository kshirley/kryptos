---
title: "Kryptos K4 Hypothesis 5"
author: "Kenny Shirley"
date: "October 5, 2019"
output: 
  html_document:
    smart: FALSE
    toc: TRUE
    theme: readable
editor_options: 
  chunk_output_type: console
---
  
```{r global-options, include = FALSE}
## Global options
knitr::opts_chunk$set(echo = TRUE, 
                      warning = FALSE, 
                      message = FALSE, 
                      cache = FALSE, 
                      comment = "")
```

```{r set-options, echo=FALSE}
#setwd("~/public_git/kryptos/code")
options(width = 80)
library(dplyr,      quietly = TRUE)
library(knitr,      quietly = TRUE)
library(tidyr,      quietly = TRUE)
library(data.table, quietly = TRUE)
library(ggplot2,    quietly = TRUE)
library(plotly,     quietly = TRUE)
library(stringi,    quietly = TRUE)
```


## K4 Hypothesis 5

Hypothesis: Running Key from 97 consecutive characters of the cipher text of K1-K3; offset by one of \{0, 1, 2, 3, ..., 25\}.

A running key cipher means that there is some sequence of 97 characters that, when combined with the cipher text, reveals the plaintext. By "combine", I mean that the cipher text letters in A-Z correspond to the integers 0, 1, ..., 25, and the letters in the running key correspond to the integers $j$ up to $j+25$, for some 'offset' $j \in 0, 1, 2, ..., 25$. In other words, there are 26 different 'versions' of the running key, depending on how you additively 'combine' the running key with the ciphertext.

### Practice cipher

Let's encode the length-97 message that comes from the opening lines of Harry Potter and the Sorcerer's Stone:

<pre>
Mr. and Mrs. Dursley, of number four, Privet Drive, were proud to say that they were perfectly normal, thank you very much. They were the last people you’d expect to be involved in anything strange or mysterious, because they just didn’t hold with such nonsense.
</pre>

``` {r code}
message <- "Mr. and Mrs. Dursley, of number four, Privet Drive, were proud to say that they were perfectly normal, thank you very much. They were the last people you’d expect to be involved in anything strange or mysterious, because they just didn’t hold with such nonsense."
message <- unlist(strsplit(message, ""))
message <- message[message %in% c(letters, LETTERS)]
message <- toupper(message)
message <- message[1:97]

# read in the kryptos cipher text:
cipher_text <- readLines("../data/ciphertext.txt")
cipher_text <- unlist(strsplit(paste(cipher_text, collapse = ""), ""))
K4 <- cipher_text[773:869]
cipher_text <- cipher_text[1:772]

# remove the question marks from the first three parts:
cipher_text <- cipher_text[cipher_text %in% LETTERS]

# now, encode the message using a specific consecutive set of 97 characters:
key <- cipher_text[11:107]

# choose some 'offset' value to determine how to combine the running key with
# the cipher text:
offset <- 7

# function to encode using the running key:
encode_running_key <- function(message, key, offset = 0) {
  m1 <- (match(message, LETTERS) - 1)  # takes values in 0, 1, ..., 25
  m2 <- (match(key, LETTERS) - 1)      # takes values in 0, 1, ..., 25
  index <- (m1 + offset + m2) %% 26 + 1
  LETTERS[index]
}

# use the function:
practice_cipher <- encode_running_key(message = message, key = key, offset = 7)
practice_cipher

```

To decode this cipher, we just have to loop through every possible combination of key and offset, and we'll evaluate the bigram and frequency log-likelihood of each candidate solution.

``` {r decode}
# read in letter frequencies:
lf <- fread("../data/letter_frequencies.csv", data.table = FALSE)

# frequency analysis function:
frequency_score <- function(sequence, letter_probs) {
  n <- length(sequence)
  sum(log(letter_probs[match(sequence, LETTERS)]), na.rm = TRUE)
}

# read in the 2-gram frequencies from the Google n-grams corpus:
two_gram <- fread("../data/count_2l.txt", data.table = FALSE)
names(two_gram) <- c("letters", "frequency")

# normalize the frequencies to avoid integer overflow:
two_gram$normalized <- two_gram$frequency / min(two_gram$frequency)

# build the transition matrix for the bigram model of English:
two_mat <- matrix(0, 26, 26)
row_index <- match(substr(two_gram$letters, 1, 1), letters)
col_index <- match(substr(two_gram$letters, 2, 2), letters)
two_mat[cbind(row_index, col_index)] <- two_gram$normalized
rownames(two_mat) <- LETTERS
colnames(two_mat) <- LETTERS

# divide by row sums to get probabilities:
theta <- two_mat / rowSums(two_mat)

# get initial state distribution:
p <- rowSums(two_mat) / sum(two_mat)

# function to compute the log-likelihood of a particular snippet of text:
markov_score <- function(sequence, trans_matrix = theta, initial_probs = p) {
  n <- length(sequence)
  row_indices <- match(sequence[1:(n - 1)], LETTERS)
  col_indices <- match(sequence[2:n], LETTERS)
  as.numeric(log(p[match(sequence[1], LETTERS)])) + 
    sum(log(theta[cbind(row_indices, col_indices)]), na.rm = TRUE)
}

# number of possible starting positions:
n_start <- length(cipher_text) - 97 + 1
n_offset <- 26
e <- expand.grid(1:n_start, 1:n_offset - 1)
e <- rename(e, start = Var1, offset = Var2)

# loop through the combinations of starting positions and offsets and test each one:
candidate <- vector("list", nrow(e))
m2 <- match(practice_cipher, LETTERS) - 1
bigram_loglik <- numeric(nrow(e))
freq_loglik <- numeric(nrow(e))
for (i in 1:nrow(e)) {
  running_key <- cipher_text[1:97 + e$start[i] - 1]
  m1 <- match(running_key, LETTERS) - 1
  offset <- e$offset[i]
  index <- (m2 - (m1 + offset)) %% 26 + 1
  candidate[[i]] <- LETTERS[index]
  bigram_loglik[i] <- markov_score(sequence = candidate[[i]])
  freq_loglik[i] <- frequency_score(sequence = candidate[[i]], 
                                    letter_probs = lf$p_wiki) 
}

df <- data.frame(e, bigram_loglik, freq_loglik, 
                 message = sapply(candidate, function(x) {
                   paste0(paste(x[1:30], collapse = ""), "...")}
                 ))


df %>% arrange(desc(bigram_loglik)) %>%
  head(10)

```

It worked. The most likely candidate solution, by far, is the correct one.

### Decode K4

Now let's try this on K4.

``` {r running-key-K4}
candidate <- vector("list", nrow(e))
m2 <- match(K4, LETTERS) - 1
bigram_loglik <- numeric(nrow(e))
freq_loglik <- numeric(nrow(e))
for (i in 1:nrow(e)) {
  running_key <- cipher_text[1:97 + e$start[i] - 1]
  m1 <- match(running_key, LETTERS) - 1
  offset <- e$offset[i]
  index <- (m2 - (m1 + offset)) %% 26 + 1
  candidate[[i]] <- LETTERS[index]
  bigram_loglik[i] <- markov_score(sequence = candidate[[i]])
  freq_loglik[i] <- frequency_score(sequence = candidate[[i]], 
                                    letter_probs = lf$p_wiki) 
}

df <- data.frame(e, bigram_loglik, freq_loglik, 
                 message = sapply(candidate, function(x) {
                   paste0(paste(x[1:30], collapse = ""), "...")}
                 ))


df %>% arrange(desc(bigram_loglik)) %>%
  head(10)

df %>% arrange(desc(freq_loglik)) %>%
  head(10)

```

**Conclusion: False.**

